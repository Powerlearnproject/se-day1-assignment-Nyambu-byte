[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18374179&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering 

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the process of developing, testing and maintaining of software. Software engineering is important as it drives innovation by providing the foundational tools to develop new technologies. Secondly, it plays a critical role in developing secure applications and systems to protect user data. lastly, software engineering enables businesses in the tech sector to transform their operations. Through enterprise software systems, automation, and digital tools. This helps companies streamline operations, reduce costs, and improve efficiency. In sectors like logistics, manufacturing, and marketing, software solutions help companies optimize supply chains, manage data, and improve decision-making

Identify and describe at least three key milestones in the evolution of software engineering.
Mastering machine - The term software engineering had not yet been coined. Code development was strongly influenced by outside forces. The main purpose of any piece of software was to optimize exploitation of the limited hardware resources. The first compilers were defined; operating systems were noninteractive. These primitive environments continued evolving up to the definition of the first low-level Computer Aided Software Engineering tools (CASE tools) facilitating interactive editing, compiling, and debugging. The lack of software development methods led to high risk and the origin of a new stage is easily noticeable.
Mastering the process - The first software crisis in this stage led to the birth of software engineering. The aim was to reduce risk during development and improve quality and productivity. Software development methodologies appeared to define and monitor software building. An important contribution of this stage was the formal modeling approach that enables implementation automation. But for industry, this formal approach was unfeasible due to a lack of tools and training. Furthermore, formal methods become unmanageable for large system development. In conclusion, in this stage, the need to focus on predesign phases and the use of more or less formal models for software specification began to appear. A number of structured methods, such as Software Requirement Engineering Methodology (SREM) and the Structured Analysis and Design Technique (SADT) were developed allowing the development of specification documents for business management software.
Mastering the complexity - The up to then dominion of hardware over software ended. Personal computers arrived and opened the fields of computer applications. The software development process would now comprehensively address analysis and design from the specification. Graphical user interface and visual programming brought software closer to customers. The use of structured family and data modeling methodologies was extended. Several CASE tools facilitated software development. However, data modeling (database) and function modeling (structured methods) still followed separate paths. These two modeling paths converged in object-oriented (OO) methods like early on in structured methodologies, they were first introduced in coding and design, and finally in specification and analysis. This approach enables efficient reuse of object-oriented software and thus improves building software productivity.
List and briefly explain the phases of the Software Development Life Cycle.
1. Planning phase - This is the first step of the process in software development which the develops get to understand what is required of the system they want to develop. This process is usually guided by data from surveys. This phase usually determines the quality of the project.
2. Defining requirements - In this stage, all the requirements for the target software are specified. This is fulfilled by utilizing SRS (Software Requirement Specification). This is a sort of document that specifies all those things that need to be defined and created during the entire project cycle.
3. Product Design - This is the phase where the software designers come up with the architecture of the product.
4. Product Development - At this stage, the fundamental development of the product starts. For this, developers use a specific programming code as per the design in the DDS. Hence, it is important for the coders to follow the protocols set by the association. Conventional programming tools like compilers, interpreters, debuggers, etc. are also put into use at this stage. Some popular languages like C/C++, Python, Java, etc. are put into use as per the software regulations.
5. Product Testing and Integration - After the development of the product, testing of the software is necessary to ensure its smooth execution. Although, minimal testing is conducted at every stage of SDLC. Therefore, at this stage, all the probable flaws are tracked, fixed, and retested. This ensures that the product confronts the quality requirements of SRS.
6. Deployment and Maintenance - After detailed testing, the conclusive product is released in phases as per the organization’s strategy. Then it is tested in a real industrial environment. It is important to ensure its smooth performance. If it performs well, the organization sends out the product as a whole. After retrieving beneficial feedback, the company releases it as it is or with auxiliary improvements to make it further helpful for the customers.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Waterfall methodology
1. Waterfall is a linear and sequential approach. The development process flows in one direction—downward like a waterfall. Each phase must be completed before moving to the next, with little to no iteration or revisiting previous stages.
2. Waterfall is rigid. Once a phase is completed, it is difficult to go back and make changes. This can lead to challenges if requirements evolve during the project, which is common in today’s fast-changing environments.
3. Upfront planning is a hallmark of Waterfall. All requirements are gathered at the beginning, and detailed planning is done before development begins. This is beneficial when requirements are well understood and unlikely to change.
4. In Waterfall, communication with stakeholders is more limited, generally occurring during the requirements gathering phase and then during testing or delivery. There’s little room for stakeholder feedback throughout the process.
5. Testing is done after the development phase in Waterfall. Since testing occurs after the build, bugs or issues can be more costly to fix since they might involve revisiting earlier stages.
Agile methodology
1. Agile is an iterative and incremental approach, where development is broken down into smaller cycles called sprints (usually 2-4 weeks). Each sprint involves a repeatable cycle of planning, design, development, and testing. At the end of each sprint, a potentially shippable product increment is delivered.
2. Agile is flexible and encourages changes even late in the development process. It embraces evolving requirements and promotes adaptability to new ideas, feedback, or changes from stakeholders during each sprint.
3. Continuous planning is essential in Agile. Requirements are gathered incrementally throughout the project, and adjustments can be made at any point based on feedback and evolving needs. Agile prioritizes collaboration over detailed upfront planning.
4. In Agile, frequent communication with stakeholders is integral. The team interacts with stakeholders regularly—often at the end of every sprint—through reviews and feedback sessions, ensuring the product evolves in line with stakeholder needs.
5. Testing is done continuously throughout the process. Every sprint includes planning for and conducting testing, allowing issues to be identified early and addressed immediately, which results in better overall product quality. 

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
Software Developer
The developer is responsible for writing the code and developing the entire software product. Aside from coding, a software developer is responsible for sending updates to the project manager and working closely with other team members, including the designer and QA engineer. The kind of software developer you hire for your team depends on your desired software. If you want a mobile application, you need an iOS or an Android developer. However, if you want to develop a web application, you need a front-end, back-end or full-stack developer.
Responsibilities
1. Developing applications, programs and systems using programming languages and frameworks.
2. Maintaining and updating software to keep it functional.
3. Collaborating with other team members to ensure best practices when developing software.
4. Report to the project manager about the progress of the software development.
QA Engineer 
The QA or quality assurance engineer creates tests that identify issues with software before it is deployed. QA engineers monitor every phase of the software development process, including development, testing, debugging and delivery. They ensure that quality is maintained at every stage of the development process and that the final product meets the requirements.
Responsibilities 
Collaborate with stakeholders to understand and clarify software requirements.
Create development standards and procedures for the programmers to follow. 
Confirm that the software meets the requirements before deployment.
Analyse the product to identify bugs and suggest changes to make them more efficient. 
Develop and execute automation scripts using open-source tools.
Project Manager 
In software development, the roles of the project manager may include helping the team to design, execute, monitor and finish their work so that the clients will receive higher-quality software products. 
Responsibilities 
1.Discuss the project and its requirements with clients and software developers.
2. Assemble and lead the software development team.
3. Create the blueprint for the project, including the scope, allocating resources, setting deadlines and laying out communication strategies.
4. Supervising each stage of the software development project.
5. Set the budget and ensure the project adheres to it as closely as possible.
6. Tracking and communicating information regarding the project milestones, deliverables and change requests.
7. Deliver the completed software to the client and regularly check its performance.   

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
An integrated development environment (IDE) is a software application that helps programmers develop software code efficiently. It increases developer productivity by combining capabilities such as software editing, building, testing, and packaging in an easy-to-use application. Just as writers use text editors and accountants use spreadsheets, software developers use IDEs to make their job easier.IDEs are important as they provide a central interface for common developer tools, making the software development process much more efficient. Developers can start programming new applications quickly instead of manually integrating and configuring different software. They also don't have to learn about all the tools and can instead focus on just one application. For example, when coding in Python, the IDE might suggest function names or display the correct syntax for different Python structures, reducing the likelihood of syntax errors.
A Version Control System (VCS) is a tool that helps developers manage changes to the source code over time. It tracks code modifications, enables collaboration between multiple developers, and provides the ability to revert to previous versions of the code if necessary. VCS is important as it tracks all changes made to a codebase, providing a complete history of the project. Each time a developer commits changes, the system saves a snapshot of the code, making it easy to see what has changed and when. It also enable for different software developers to work together simultaneously without overwriting each others work. Lastly VCS is important as it ensures that the source code is stored securely and backed up. If something goes wrong, developers can revert to previous versions of the code, reducing the risk of losing critical work. An example of the importance of VCS is when a bug is introduced and the codebase becomes unstable, Git allows the developer to easily checkout a stable version from the repository, restoring the project to a working state.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
1. The rapid pace of technological change means that new programming languages, frameworks, and tools constantly emerge. It’s challenging for engineers to stay updated with the latest trends while balancing ongoing projects. To overcome this challenge it is important for software engineers to dedicate regular time to self-learning via online courses, blogs, and tutorials.
2. In SOftware development it is common for project requirements to be unclear or change frequently during development. This leads to misunderstandings and missed deadlines, as engineers might not fully understand the scope or expectations. To overcome this challenge it is imortant for software engineers to adopt Agile methodologies to allow for frequent updates and feedback on the progress of the project. This ensures that the project remains aligned with changing requirements.
3. As projects grow, codebases can become large and difficult to manage, making it challenging to maintain code quality, readability, and stability. To overcome this challenge it is important for software enginners to utilize tools like Git to manage the codebase, track changes, and collaborate across teams.
4. Security is a constant concern, especially as cyberattacks become more sophisticated. Software engineers must ensure that applications are resistant to common security vulnerabilities. some of the strategies to overcome this challenge is to follow best practices outlined by credible organizations  to write secure code and prevent common vulnerabilities. Also, Ensure that sensitive data is encrypted both in transit and at rest. Implement strong authentication mechanisms like multi-factor authentication (MFA) where necessary.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit tests are very low level and close to the source of an application. They consist in testing individual methods and functions of the classes, components, or modules used by your software. Unit tests are generally quite cheap to automate and can run very quickly by a continuous integration server. It is important as it helps identify bugs in the earliest phase of development, which makes them easier and cheaper to fix. It also helps in simplification of debugging as the error is usually localized to a specific function or method, making it easier for developers to pinpoint the issue.
Integration tests verify that different modules or services used by your application work well together. For example, it can be testing the interaction with the database or making sure that microservices work together as expected. These types of tests are more expensive to run as they require multiple parts of the application to be up and running. Integration tests are important as they help catch issues that arise from the interaction between components, such as mismatched data formats, incorrect API calls, or integration points. Additionally, it ensures that data flows properly between modules, such as checking that data passed between a front-end application and a back-end API is correctly handled.
System testing involves testing the entire application as a complete system. It evaluates how the integrated components of the application work together in a real-world environment. System tests cover both functional and non-functional requirements (e.g., performance, security, usability). It is important as it ensures  that the system meets the specified requirements and performs as intended across all use cases. Additionally, it helps uncover issues that arise when the system is used in its entirety, such as memory leaks, data inconsistencies, or security vulnerabilities. Lastly, it helps check whether the system meets both the functional aspects (does the system meet business needs?) and the non-functional aspects (performance, security, and scalability).

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the process where you guide generative artificial intelligence (generative AI) solutions to generate desired outputs. Even though generative AI attempts to mimic humans, it requires detailed instructions to create high-quality and relevant output. In prompt engineering, you choose the most appropriate formats, phrases, words, and symbols that guide the AI to interact with your users more meaningfully. 
Prompt engineering is quite important as it gives developers more control over users' interactions with the AI. Effective prompts provide intent and establish context to the large language models. They help the AI refine the output and present it concisely in the required format. Also, Prompt engineering makes it easy for users to obtain relevant results in the first prompt. It helps mitigate bias that may be present from existing human bias in the large language models’ training data. 

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Vague Prompt
"Can you tell me something about marketing"
Improved prompt
"Explain the key differences between digital marketing and traditional marketing, and provide examples of when each is most effective."
Why the Improved Prompt is More Effective:
1. It provides clear direction as the responder knows exactly what the question is asking and what areas to focus on.
2. It promotes a structured answer by asking for differences and examples, it guides the response to be more detailed and practical, which will make the answer more useful.
3. It avoids ambiguity - The vague prompt could lead to a wide-ranging or unfocused response, while the improved prompt narrows the scope to ensure that the answer is both relevant and actionable.
